# install the library 
pip install networkx torch torch-geometric community
#code starts here
import networkx as nx
import community as community_louvain
import torch
import torch_geometric
from torch_geometric.nn import GCNConv
from torch_geometric.data import Data
import matplotlib.pyplot as plt

# Create a sample social network (graph) using NetworkX
G = nx.erdos_renyi_graph(100, 0.05)  # A random graph of 100 nodes and 5% edge probability

# Visualization of the graph
plt.figure(figsize=(8, 6))
nx.draw(G, with_labels=True, node_size=100, font_size=10)
plt.title("Social Network (Random Graph)")
plt.show()

# Louvain method for community detection
def louvain_community_detection(G):
    partition = community_louvain.best_partition(G)
    return partition

# Get communities using the Louvain method
partition = louvain_community_detection(G)
print("Louvain Method Community Partition:", partition)

# Visualize communities with Louvain partition
plt.figure(figsize=(8, 6))
pos = nx.spring_layout(G)
cmap = plt.cm.rainbow
colors = [cmap(partition[node] / max(partition.values())) for node in G.nodes()]
nx.draw(G, pos, node_color=colors, with_labels=True, node_size=100, font_size=10)
plt.title("Communities Detected with Louvain")
plt.show()

# Prepare the graph data for GNN (Graph Neural Network) using PyTorch Geometric
# Convert NetworkX graph to PyTorch Geometric format
def nx_to_torch_geometric(G):
    edge_index = torch.tensor(list(G.edges), dtype=torch.long).t().contiguous()
    x = torch.eye(G.number_of_nodes(), dtype=torch.float)  # Identity matrix as node features (simple example)
    data = Data(x=x, edge_index=edge_index)
    return data

# Get PyTorch Geometric graph data
data = nx_to_torch_geometric(G)

# Define a simple Graph Convolutional Network (GCN) for community detection
class GCN(torch.nn.Module):
    def __init__(self, in_channels, out_channels):
        super(GCN, self).__init__()
        self.conv1 = GCNConv(in_channels, 16)
        self.conv2 = GCNConv(16, out_channels)

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = torch.relu(self.conv1(x, edge_index))
        x = self.conv2(x, edge_index)
        return x

# Initialize GCN model
model = GCN(in_channels=G.number_of_nodes(), out_channels=4)  # 4 is an arbitrary number of clusters/communities
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
criterion = torch.nn.CrossEntropyLoss()

# Training loop
def train(model, data, epochs=100):
    for epoch in range(epochs):
        model.train()
        optimizer.zero_grad()
        out = model(data)
        # Here, we use the Louvain method's partition as ground truth labels (as a placeholder)
        labels = torch.tensor([partition[node] for node in data.x], dtype=torch.long)
        loss = criterion(out, labels)
        loss.backward()
        optimizer.step()

        if epoch % 10 == 0:
            print(f'Epoch {epoch+1}/{epochs}, Loss: {loss.item()}')

# Train the model
train(model, data)

# Community detection using the trained GCN model
def detect_communities_gcn(model, data):
    model.eval()
    out = model(data)
    _, predicted = out.max(dim=1)
    return predicted

# Predict communities using GCN
predicted_communities = detect_communities_gcn(model, data)
print("Predicted Communities:", predicted_communities)

# Visualize the GCN's predicted communities
plt.figure(figsize=(8, 6))
colors = [predicted_communities[node].item() for node in G.nodes()]
nx.draw(G, pos, node_color=colors, with_labels=True, node_size=100, font_size=10, cmap=plt.cm.rainbow)
plt.title("Communities Detected by GCN")
plt.show()
